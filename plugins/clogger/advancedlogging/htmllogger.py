# -*- coding: utf-8 -*-
from plugins.clogger.advancedlogging import BasicMessagesLogger
from time import strftime, localtime
import os
import random
from lxml import etree
import re
class HTMLLogger(BasicMessagesLogger):
    def __init__(self,logdir,autolog=False):
        self.logdir = logdir
        self.logging = autolog
        self.narray = {}
        self.letters = ['א','ב','ג','ד','ה','ו','ז','ח','ט','י','כ','ל','מ','נ','ס','ע','פ','צ','ק','ר','ש','ת']
        self.htmlexists = False
    def LogMessage(self,sender,msg,me=False):
        colorarray = ['one','two','three','four','five','six','seven','eight','nine','ten','eleven','twelve','thirteen','fourteen','fifteen']
        if self.logging and sender != 'NickServ':
            self.d = strftime("%d",localtime())
            self.m = strftime("%m",localtime())
            self.y = strftime("%Y",localtime())
            self.h = strftime("%H:%M:%S",localtime())
            if os.path.exists(self.logdir+self.y+'/'+self.m+'/'+self.d+'.html') or os.path.isdir(self.logdir+self.y+'/'+self.m):
                self.htmlexists = True
            elif os.path.isdir(self.logdir+self.y):
                os.mkdir(self.logdir+self.y+'/'+self.m)
            elif os.path.isdir(self.logdir):
                os.mkdir(self.logdir+self.y)
                os.mkdir(self.logdir+self.y+'/'+self.m)
            else:
                os.mkdir(self.logdir)
                os.mkdir(self.logdir+self.y)
                os.mkdir(self.logdir+self.y+'/'+self.m)
            self.logf = open(self.logdir+self.y+'/'+self.m+'/'+self.d+'.html','ab+')
            if self.narray.has_key(sender):
                color = self.narray[sender]
            else:
                color = colorarray[random.randrange(0,len(colorarray)-1,1)]
                self.narray[sender] = str(color)
            if self.htmlexists and len(self.logf.read()) != 0:
                self.parser = etree.HTMLParser()
                self.htmltree = etree.parse(self.logdir+self.y+'/'+self.m+'/'+self.d+'.html',self.parser).getroot()
                self.body = self.htmltree[1]
                print self.body
            else:
                self.htmltree = etree.Element('html')
                self.head = etree.SubElement(self.htmltree,'head')
                self.title = etree.SubElement(self.head,'title')
                self.title.text = '%s/%s/%s IRC log (generated by Soombot channel logger plugin).' % (self.d,self.m,self.y)
                self.meta1 = etree.SubElement(self.head,'meta')
                self.meta1.set('http-equiv','content-type')
                self.meta1.set('content','text/html;charset=UTF-8')
                self.meta2 = etree.SubElement(self.head,'meta')
                self.meta2.set('name','generator')
                self.meta2.set('content','Hoborg 2')
                self.css = etree.SubElement(self.head,'link')
                self.css.set('rel','stylesheet')
                self.css.set('type','text/css')
                self.css.set('href','../../style.css')
                self.body = etree.SubElement(self.htmltree,'body')
            msgdiv = etree.SubElement(self.body,'div')
            hourspan = etree.SubElement(msgdiv,'span')
            hourspan.text = '('+self.h+')'
            senderspan = etree.SubElement(msgdiv,'span')
            senderspan.set('class',color)
            if me:
                senderspan.text = '*%s ' % sender
            else:
                senderspan.text = '<'+sender+'>'
            msgspan = etree.SubElement(msgdiv,'span')
            if msg[0] in self.letters:
                msgspan.set('class','rtl')
                msgdiv.set('class','message-rtl')
            else:
                msgspan.set('class','ltr')
                msgdiv.set('class','message')
            try:
                msgspan.text = unicode(msg,"UTF-8")
            except UnicodeDecodeError, e:
                raise UnicodeDecodeError, e
            self.logf.close()
            os.remove(self.logdir+self.y+'/'+self.m+'/'+self.d+'.html')
            self.logf = open(self.logdir+self.y+'/'+self.m+'/'+self.d+'.html','ab+')
            self.logf.write(etree.tostring(self.htmltree,pretty_print=True, method="html",encoding="UTF-8"))
            self.logf.flush()
